#!/usr/bin/env lua
--[[
===============================================================================
This script is part of the OpenHPC project.

It may have been modified from the default version supplied by the underlying
release package (if available) in order to apply patches, perform customized
build/install configurations, and supply additional files to support
desired integration conventions.

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License. You may
obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License
===============================================================================
]]

---@diagnostic disable: undefined-field

local function app_version()
    return "1.0.0"
end

local function description()
    return [[
ONEAPI-MODGEN
    OpenHPC - Lmod Module Generator for Intel(R) oneAPI Toolkits

    Creates and manages OpenHPC Lmod module creation for Intel(R) oneAPI
    toolkits and legacy software tools. The default installation path
    /opt/intel/oneapi is used to locate installed versions. Other
    installations can be added manually using the root path for that
    installation.
    ]]
end

require "io"
require "os"
require "lfs"                         -- lua-filesystem (already required by Lmod)
local libgen = require "posix.libgen" -- lua-posix (already required by Lmod)
local fnmatch = require "posix.fnmatch"
local stdlib = require "posix.stdlib"
local unistd = require "posix.unistd"

-- Global constants
C = {}
-- C.OHPCROOT = (os.getenv("OHPCROOT") or "/opt/ohpc")
C.DEBUG = (os.getenv("MODGEN_DEBUG") or false)
C.OHPCROOT = "/home/devel/test"
C.MODPATH = C.OHPCROOT .. "/pub/modulefiles"
C.DEPPATH = C.OHPCROOT .. "/pub/moduledeps"
C.ONEAPIMODS = C.DEPPATH .. "/oneapi"
C.RTMODS = C.MODPATH .. "/intel-rt"
C.ONEAPIPATH = "/opt/intel/oneapi"
C.MODSCRIPT = "/modulefiles-setup.sh"
C.SCRIPTOPTS = " --force --output-dir="
C.GNU = "12"
C.SIGTEXT = "-- AUTOGENERATED BY ONEAPIMODGEN"
-- Lock the constant table
C = setmetatable({}, {
    __index = C,
    __newindex = function(_, _, _)
        error("Attempt to alter constant value", 2)
    end,
    __metatable = false
})

-- Metatable for storing module list in memory
ModMT = {
    __index = {
        -- Store a new module in the table
        new = function(self, v, f, i)
            -- v = version
            self[v] = {
                file = f,  -- Full path and filename
                isdiff = i -- Modified file (bool)
            }
            return self
        end,
        -- Find and return the latest version in module table
        latest = function(self)
            local vtab = {}
            for k, _ in pairs(self) do
                table.insert(vtab, k)
            end
            table.sort(vtab)
            return vtab[#vtab]
        end
    }
}

-- Define available commands
Commands = setmetatable({}, {
    __index = {
        new = function(self, n, h, a, c, i)
            self[n] = {      -- n = Command name
                help = h,    -- Help text
                argc = a,    -- No. of required arguments (int)
                call = c,    -- Handler function
                ishidden = i -- Hide command (bool)
            }
            return self
        end
    }
})

-- Define module types and their attributes
ModTypes = setmetatable({}, {
    __index = {
        new = function(self, m, h, p, t, f, r)
            self[m] = {   -- m = module type
                help = h, -- Help text
                path = p, -- LMOD module path ---@field path string
                name = t, -- Tool name
                find = f, -- search text for full version only
                rt = r    -- search text for runtimes
            }
            return self
        end
    }
})

-- Version defaults for each tool in each Toolkit
Defaults = setmetatable({ xref = {} }, {
    __index = {
        -- Simplified format for adding a new version
        -- Defaults:add(toolkit_version, { tool_version = {tool1, tool2, ...}, ... })
        new = function(self, tkver, list)
            if type(list) ~= "table" then
                error("Defaults:new-version list is not a table" .. tkver, 2)
            end
            local output = {}
            local compver = ""
            for k, v in pairs(list) do
                if type(v) ~= "table" then
                    error("Defaults:new-tool list is not a table: " .. k, 2)
                end
                if k == nil then
                    error("Defaults:new-missing tool version " .. k, 2)
                end
                for _, t in ipairs(v) do
                    if type(t) ~= "string" or t == nil then
                        error("Defaults:new-tool name is not a string " .. k .. ": " .. t, 2)
                    end
                    if t == "compiler" then
                        compver = k
                    else
                        output[t] = k
                    end
                end
            end
            if compver == "" then
                error("Defaults:new-missing compiler version " .. tkver, 2)
            end
            self[compver] = output
            self.xref[compver] = tkver
            return self
        end,
        toolkit = function(self, tkver)
            for k, v in pairs(self.xref) do
                if v == tkver then
                    return k
                end
            end
        end
    }
})

Defaults:new("2021.1.0", {
    ["10.0.0"] = { "debugger" },
    ["2021.1.1"] = { "advisor", "ccl", "clck", "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dal", "dev-utilities", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "dpl", "init_opencl", "inspector", "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64", "itac", "mkl", "mkl32", "mpi", "oclfpga", "tbb", "tbb32", "vpl", "vtune" }
})
Defaults:new("2021.1.2", {
    ["10.0.0"] = { "debugger" },
    ["2021.1.1"] = { "advisor", "ccl", "clck", "dal", "dev-utilities", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "dpl", "inspector", "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64", "itac", "mkl", "mkl32", "mpi", "tbb", "tbb32", "vpl" },
    ["2021.1.2"] = { "compiler", "compiler32", "compiler-rt", "compiler-rt32", "init_opencl", "oclfpga", "vtune" }
})
Defaults:new("2021.2.0", {
    ["10.1.1"] = { "debugger" },
    ["2021.2.0"] = { "advisor", "ccl", "clck", "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dal", "dev-utilities", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "dpl", "init_opencl", "inspector", "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64", "itac", "mkl", "mkl32", "mpi", "oclfpga", "tbb", "tbb32", "vtune" },
    ["2021.2.2"] = { "vpl" }
})
Defaults:new("2021.3.0", {
    ["10.1.2"] = { "debugger" },
    ["2021.3.0"] = { "advisor", "ccl", "clck", "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dal", "dev-utilities", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "init_opencl", "inspector", "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64", "itac", "mkl", "mkl32", "mpi", "oclfpga", "tbb", "tbb32" },
    ["2021.4.0"] = { "dpl", "vpl" },
    ["2021.5.0"] = { "vtune" }
})
Defaults:new("2021.4.0", {
    ["10.2.4"] = { "debugger" },
    ["2021.4.0"] = { "advisor", "ccl", "clck", "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dal", "dev-utilities", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "icc", "icc32", "init_opencl", "inspector", "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64", "itac", "mkl", "mkl32", "mpi", "oclfpga", "tbb", "tbb32" },
    ["2021.5.0"] = { "dpl" },
    ["2021.6.0"] = { "vpl" },
    ["2021.7.1"] = { "vtune" }
})
Defaults:new("2022.1.1", {
    ["2021.5.0"] = { "ccl", "clck", "debugger", "intel_ippcp_ia32", "intel_ippcp_intel64", "itac", "mpi", "tbb", "tbb32" },
    ["2021.5.1"] = { "dal", "dev-utilities", "intel_ipp_ia32", "intel_ipp_intel64" },
    ["2021.6.0"] = { "dpl" },
    ["2022.0.0"] = { "advisor", "dpct", "inspector", "vpl", "vtune" },
    ["2022.0.1"] = { "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "icc", "icc32", "init_opencl", "mkl", "mkl32", "oclfpga" }
})
Defaults:new("2022.1.2", {
    ["2021.5.0"] = { "clck", "debugger", "itac" },
    ["2021.5.1"] = { "ccl", "intel_ippcp_ia32", "intel_ippcp_intel64", "mpi", "tbb", "tbb32" },
    ["2021.5.2"] = { "dev-utilities", "intel_ipp_ia32", "intel_ipp_intel64" },
    ["2021.5.3"] = { "dal" },
    ["2021.6.0"] = { "dpl" },
    ["2022.0.0"] = { "advisor", "dpct", "inspector", "vpl", "vtune" },
    ["2022.0.2"] = { "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "icc", "icc32", "init_opencl", "mkl", "mkl32", "oclfpga" }
})
Defaults:new("2022.2.0", {
    ["2021.6.0"] = { "ccl", "clck", "dal", "debugger", "dev-utilities", "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64", "itac", "mpi", "tbb", "tbb32" },
    ["2021.7.0"] = { "dpl" },
    ["2022.1.0"] = { "advisor", "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "icc", "icc32", "init_opencl", "inspector", "mkl", "mkl32", "oclfpga", "vpl" },
    ["2022.2.0"] = { "vtune" }
})
Defaults:new("2022.3.0", {
    ["2021.6.1"] = { "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2021.7.0"] = { "ccl", "clck", "dal", "debugger", "dev-utilities", "itac", "mpi", "tbb", "tbb32" },
    ["2021.7.1"] = { "dpl" },
    ["2022.2.0"] = { "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "icc", "icc32", "init_opencl", "mkl", "mkl32", "oclfpga", "vpl" },
    ["2022.3.0"] = { "advisor", "inspector" },
    ["2022.4.0"] = { "vtune" }
})
Defaults:new("2022.3.1", {
    ["2021.6.2"] = { "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2021.7.1"] = { "ccl", "clck", "dal", "debugger", "dev-utilities", "itac", "mpi", "tbb", "tbb32" },
    ["2021.7.2"] = { "dpl" },
    ["2022.2.1"] = { "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "icc", "icc32", "init_opencl", "mkl", "mkl32", "oclfpga" },
    ["2022.2.5"] = { "vpl" },
    ["2022.3.1"] = { "advisor", "inspector" },
    ["2022.4.1"] = { "vtune" }
})
Defaults:new("2023.0.0", {
    ["2021.6.3"] = { "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2021.7.0"] = { "intel_ipp_ia32", "intel_ipp_intel64" },
    ["2021.7.2"] = { "clck" },
    ["2021.8.0"] = { "ccl", "dev-utilities", "itac", "mpi", "tbb", "tbb32" },
    ["2022.0.0"] = { "dpl" },
    ["2023.0.0"] = { "advisor", "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dal", "debugger", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "icc", "icc32", "init_opencl", "inspector", "mkl", "mkl32", "oclfpga", "vpl", "vtune" }
})
Defaults:new("2023.1.0", {
    ["2021.7.0"] = { "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2021.7.3"] = { "clck" },
    ["2021.8.0"] = { "intel_ipp_ia32", "intel_ipp_intel64" },
    ["2021.9.0"] = { "ccl", "dev-utilities", "itac", "mpi", "tbb", "tbb32" },
    ["2022.1.0"] = { "dpl" },
    ["2023.1.0"] = { "advisor", "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dal", "debugger", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "icc", "icc32", "init_opencl", "inspector", "mkl", "mkl32", "oclfpga", "vtune" }
})
Defaults:new("2023.2.0", {
    ["2021.10.0"] = { "ccl", "dev-utilities", "itac", "mpi", "tbb", "tbb32" },
    ["2021.8.0"] = { "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2021.9.0"] = { "intel_ipp_ia32", "intel_ipp_intel64" },
    ["2022.2.0"] = { "dpl" },
    ["2023.2.0"] = { "advisor", "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dal", "debugger", "dnnl", "dnnl-cpu-gomp", "dnnl-cpu-iomp", "dnnl-cpu-tbb", "dpct", "init_opencl", "inspector", "mkl", "mkl32", "oclfpga", "vtune" }
})
Defaults:new("2024.0.0", {
    ["2021.10"] = { "intel_ipp_ia32", "intel_ipp_intel64" },
    ["2021.11"] = { "mpi", "tbb", "tbb32" },
    ["2021.11.0"] = { "ccl" },
    ["2021.9"] = { "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2022.0"] = { "itac" },
    ["2022.3"] = { "dpl" },
    ["2024.0"] = { "advisor", "inspector", "mkl", "mkl32", "vtune" },
    ["2024.0.0"] = { "compiler", "compiler32", "compiler-rt", "compiler-rt32", "dal", "debugger", "dev-utilities", "dpct", "ifort", "ifort32", "oclfpga" },
    ["3.3.0"] = { "dnnl" }
})
Defaults:new("2024.0.1", {
    ["2021.10"] = { "intel_ipp_ia32", "intel_ipp_intel64" },
    ["2021.11"] = { "mpi", "tbb", "tbb32" },
    ["2021.11.2"] = { "ccl" },
    ["2021.9"] = { "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2022.0"] = { "itac" },
    ["2022.3"] = { "dpl" },
    ["2024.0"] = { "advisor", "inspector", "mkl", "mkl32", "vtune" },
    ["2024.0.0"] = { "dal", "debugger", "dev-utilities", "dpct", "oclfpga" },
    ["2024.0.2"] = { "compiler", "compiler32", "compiler-rt", "compiler-rt32", "ifort", "ifort32" },
    ["3.3.0"] = { "dnnl" }
})
Defaults:new("2024.1.0", {
    ["2021.11"] = { "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2021.12"] = { "mpi", "tbb", "tbb32" },
    ["2021.12.0"] = { "ccl" },
    ["2022.5"] = { "dpl" },
    ["2024.0.0"] = { "dal", "dev-utilities" },
    ["2024.1"] = { "advisor", "mkl", "mkl32", "vtune" },
    ["2024.1.0"] = { "compiler", "compiler32", "compiler-intel-llvm", "compiler-intel-llvm32", "compiler-rt", "compiler-rt32", "debugger", "dpct", "ifort", "ifort32", "oclfpga" },
    ["3.4.0"] = { "dnnl" }
})
Defaults:new("2024.2.0", {
    ["2021.12"] = { "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2021.13"] = { "mpi", "tbb", "tbb32" },
    ["2021.13.0"] = { "ccl" },
    ["2022.6"] = { "dpl" },
    ["2024.0.0"] = { "dal" },
    ["2024.2"] = { "advisor", "mkl", "mkl32", "vtune" },
    ["2024.2.0"] = { "compiler", "compiler32", "compiler-intel-llvm", "compiler-intel-llvm32", "compiler-rt", "compiler-rt32", "debugger", "dev-utilities", "dpct", "ifort", "ifort32" },
    ["3.5.0"] = { "dnnl" }
})
Defaults:new("2024.2.1", {
    ["2021.12"] = { "intel_ipp_ia32", "intel_ipp_intel64", "intel_ippcp_ia32", "intel_ippcp_intel64" },
    ["2021.13"] = { "mpi", "tbb", "tbb32" },
    ["2021.13.1"] = { "ccl" },
    ["2022.6"] = { "dpl" },
    ["2024.0.0"] = { "dal" },
    ["2024.2"] = { "advisor", "mkl", "mkl32", "vtune" },
    ["2024.2.0"] = { "dev-utilities", "dpct" },
    ["2024.2.1"] = { "compiler", "compiler32", "compiler-intel-llvm", "compiler-intel-llvm32", "compiler-rt", "compiler-rt32", "debugger", "ifort", "ifort32" },
    ["3.5.0"] = { "dnnl" }
})

------------------------------
-- Generic Global Functions --
------------------------------

-- Return first value
function First(x, ...)
    return x
end

-- Concatenate all arguments into a path
function PathCat(r, ...)
    local path = tostring(r)
    for _, v in ipairs({ ... }) do
        path = path .. "/" .. tostring(v)
    end
    path = path:gsub("/+", "/")
    return path
end

-- Execute a shell command string and return output
function RunOSCommand(cmd)
    local handle = assert(io.popen(cmd, 'r'),
        "Process open error: '" .. cmd .. "'")
    handle:flush()
    local cmdoutput = assert(handle:read('*a'),
        "Process read eoor: '" .. cmd .. "'")
    -- Command returns STDOUT (minus newline) and if no error
    return cmdoutput:gsub("\n+$", ""), not handle:close()
end

-- Convert multi-line string to array
function StringtoArray(str)
    local splitstring = {}
    for l in str:gmatch("[^\n]*") do
        table.insert(splitstring, l)
    end
    return splitstring
end

-- Read the first line of a file
function ReadFirstLine(filename)
    local fh, err = io.open(filename, "r")
    if fh then
        local line, err = fh:read()
        fh:close()
        if line and not err then
            return line, nil
        else
            return nil, "Cannot read file " .. filename ..
                "\n   " .. tostring(err)
        end
    else
        return nil, "Cannot open file " .. filename ..
            "\n   " .. tostring(err)
    end
end

-- Move a file to new name and add extension
function BackupFIle(filename, ext)
    local newext = ext or ".backup"
    local success, err = os.rename(filename, filename .. newext)
    if not success then
        return nil, "Cannot rename " .. filename .. "\n   " .. tostring(err)
    else
        return filename .. newext
    end
end

-- Write a string to a file and close it
function WriteFile(filename, data)
    local fh, err = io.open(filename, "w")
    if fh then
        local success, err = fh:write(data)
        fh:close()
        if not success then
            return nil, "Cannot write to file " .. filename ..
                "   \n" .. tostring(err)
        else
            return true, ""
        end
    else
        return nil, "Cannot open file " .. filename .. "   \n" .. tostring(err)
    end
end

-- Remove a directory if empty
function RemoveDir(path)
    if lfs.attributes(path, "mode") == "directory" and ListDir(path) == nil then
        lfs.rmdir(path)
    end
end

-- Insert into table if not nil
function InsertValue(t, v)
    if v ~= nil and v ~= "" and v ~= false then
        table.insert(t, v)
    end
end

-- List directory entries, minus . and ..
function ListDir(path, isRecursive, pattern, filetype)
    local list = {}
    local fullpath
    for entry in lfs.dir(path) do
        if entry ~= "." and entry ~= ".." then
            fullpath = PathCat(path, entry)
            if lfs.attributes(fullpath, "mode") == "directory" and isRecursive then
                for _, e in ipairs(ListDir(fullpath, true, pattern, filetype)) do
                    InsertValue(list, e)
                end
            end
            if (pattern == nil or fnmatch(pattern, entry)) and
                (filetype == nil or lfs.symlinkattributes(fullpath, "mode") == filetype) then
                InsertValue(list, fullpath)
            end
        end
    end
    return list
end

-- Table dump for debugging
function TDump(t)
    local output = ""
    for k, v in pairs(t) do
        if type(v) == "table" then
            output = output .. "{\n" .. TDump(v) .. "\n}"
        else
            output = output .. k .. " = " .. tostring(v) .. ",\n"
        end
    end
    return output
end

---------------------
-- Local Functions --
---------------------

-- Print in consistent format and to STDERR as needed
local function printformat(txt, mode)
    if mode == "warning" then
        if not assert(io.stderr:write("WARNING: " .. txt .. "\n"),
                "Cannot write to STDERR") then
            os.exit(1)
        end
        return true
    end
    if mode == "debug" then
        if C.DEBUG then
            if not assert(io.stderr:write("*** DEBUG\n" .. txt .. "\n***\n"),
                    "Cannot write to STDERR") then
                os.exit(1)
            end
        end
        return true
    end
    if mode == "error" then
        assert(io.stderr:write("\nERROR: " .. txt .. "\n\n"),
            "Cannot write to STDERR")
        os.exit(1)
    end
    if mode == "header" then
        print("\n=== " .. txt .. " ===")
        return true
    end
    if mode == "step" then
        print("  - " .. txt)
        return true
    end
    if mode == "substep" then
        print("       " .. txt)
        return true
    end
    if mode == "info" or not mode then
        print(txt)
        return true
    end
    error("Mode " .. mode .. " is not defined.", 2)
    return nil
end

-- Check that a directory exists, and either create it or terminate
local function dir_exists(path, isrequired)
    if path:sub(1, 1) ~= "/" then
        printformat("Not absolute directory: " .. path, "error")
    end
    local mode = lfs.attributes(path, "mode")
    printformat("Reading directory = mode " .. path .. " = " .. mode, "debug")
    local iserror = false
    local errortext = ""
    if not mode then
        if isrequired then
            if dir_exists(libgen.dirname(path), true) then
                iserror, errortext = lfs.mkdir(path)
            else
                iserror = true
            end
            if iserror then
                printformat("Cannot create directory " .. path .. "\n" .. errortext, "error")
                return false
            else
                return true
            end
        else
            return false
        end
    else -- mode is set
        if mode ~= "directory" then
            if isrequired then
                printformat(path .. " is not a directory", "error")
            else
                printformat(path .. " is not a directory", "warning")
                return false
            end
        else
            return true
        end
    end
end

-- Return a string containing formatted modulefile text
local function moduletext(modtype, ver, path)
    local header = function(v)
        local h = ""
        if v ~= nil then
            h = "local version = " .. v .. "\n\n"
        end
        return C.SIGTEXT .. " " .. app_version() .. "\n" ..
            "-- Remove the above line to customize this file.\n" ..
            "-- If (re)moved, updates will be written to <modname>.lua.new\n\n" .. h
    end

    local defaults = function(v)
        if type(Defaults[v]) == "table" then
            return [[

-- Set default oneAPI Toolkit modules for the current compiler
local defaultsfile = "]] .. PathCat(C.ONEAPIMODS, "/.modulerc/", Defaults.xref[ver] .. ".lua") .. [["
if isFile(defaultsfile) then
  prepend_path(\"LMOD_MODULERCFILE\", defaultsfile)
end

]]
        else
            return ""
        end
    end

    -- Template for Intel(R) oneAPI compilers
    if modtype == "oneapi" then
        return (header(ver) .. [[
help("\nThis module makes all modules for oneAPI Toolkits\n" ..
  "available to load. It does not load any oneAPI modules\n"
)

whatis("Name: Intel(R) oneAPI Toolkit")
whatis("Description: Intel(R) oneAPI Toolkit module environment")
whatis("URL: https://www.intel.com/content/www/us/en/" ..
    "developer/tools/oneapi/toolkits.html")

-- update module path to add oneAPI modules
prepend_path("MODULEPATH", "]] .. C.ONEAPIMODS .. [[")

]])
    end -- modtype=oneapi

    -- Template for Intel(R) oneAPI compilers
    if modtype == "compiler" then
        return (header(ver) .. [[
help("\nThis module loads the oneAPI compiler environment.\n" ..
  "See the man pages for icc, icpc, and ifort for detailed information\n" ..
  " on available compiler options and command-line syntax.\n" ..
  "\nVersion " .. version .. "\n"
)

whatis("Name: Intel(R) Compiler")
whatis("Version: " .. version)
whatis("Category: compiler, runtime support")
whatis("Description: Intel(R) Compiler Family (C/C++/Fortran for x86_64)")
whatis("URL: http://software.intel.com/en-us/articles/intel-compilers/")

-- update module path hierarchy
prepend_path("MODULEPATH", "]] .. C.ONEAPIMODS .. [[")
prepend_path("MODULEPATH", "]] .. C.DEPPATH .. [[/intel")
]] .. defaults(ver) .. [[
-- Assume no PAC device; allow override on each node
if not os.getenv("ACL_SKIP_BSP_CONF") then
    setenv("ACL_SKIP_BSP_CONF", "1")
end

load("compiler/" .. version)
load("mkl")

family("compiler")

]])
    end -- modtype=intelcompiler

    -- Template for Intel(R) oneAPI compilers
    if modtype == "gnu-mkl" then
        return (header(ver) .. [[
help("\nConfigures oneAPI MKL environment\n" ..
  "\nVersion " .. version .. "\n"
)

whatis("Name: Intel(R) Math Kernel Library")
whatis("Version: " .. version)
whatis("Category: library, runtime support")
whatis("Description: Intel(R) Math Kernel Library for C/C++ and Fortran")
whatis("URL: https://software.intel.com/en-us/en-us/intel-mkl")

-- update module path hierarchy
prepend_path("MODULEPATH", "]] .. C.ONEAPIMODS .. [[")

load("mkl/" .. version)
]])
    end -- modtype="gnu-mkl"

    -- Template for Intel(R) oneAPI MPI library
    if modtype == "mpi" then
        return (header(ver) .. [[
help("\nThis module loads the Intel MPI environment.\n" ..
  "   mpiifort  (Fortran source)\n" ..
  "   mpiicc    (C   source)\n" ..
  "   mpiicpc   (C++ source)\n" ..
  "\nVersion " .. version .. "\n"
)

whatis("Name: Intel MPI")
whatis("Version: " .. version)
whatis("Category: library, runtime support")
whatis("Description: Intel MPI Library (C/C++/Fortran for x86_64)")
whatis("URL: http://software.intel.com/en-us/articles/intel-mpi-library")

-- For convenience, redirect standard mpicc/mpicxx/mpifort
-- to use oneAPI icc/icpc/ifort instead of gcc/g++/gfortran
setenv("I_MPI_CC",   "icc")
setenv("I_MPI_CXX",  "icpc")
setenv("I_MPI_FC",   "ifort")
setenv("I_MPI_F77",  "ifort")
setenv("I_MPI_F90",  "ifort")

setenv("MPI_DIR",    "]] .. PathCat(path, "mpi", ver) .. [[")

prepend_path("MODULEPATH", "]] .. C.ONEAPIMODS .. [[")
prepend_path("MODULEPATH", "]] .. C.DEPPATH .. [[/intel-impi")

load("mpi/" .. version)

family("MPI")

]])
    end -- modtype="mpi"

    -- Template for Intel(R) oneAPI MPI library for gnu/gnuXX
    if modtype == "gnu-mpi" or modtype == "gnu" .. C.GNU .. "-mpi" then
        local gnu = modtype:gsub("-mpi", "")
        return (header(ver) .. [[
    help("\nThis module loads the Intel MPI environment " ..
      "for use with ]] .. gnu .. [[\n" ..
      "   mpif90   (Fortran source)\n" ..
      "   mpicc    (C   source)\n" ..
      "   mpicxx   (C++ source)\n" ..
      "\nVersion " .. version .. "\n"
    )

    whatis("Name: Intel MPI")
    whatis("Version: " .. version)
    whatis("Category: library, runtime support")
    whatis("Description: Intel MPI Library (C/C++/Fortran for x86_64)")
    whatis("URL: http://software.intel.com/en-us/articles/intel-mpi-library")

    -- Set wrappers to GNU compilers gcc/g++/gfortran
    setenv("I_MPI_CC",   "gcc")
    setenv("I_MPI_CXX",  "gxx")
    setenv("I_MPI_FC",   "gfortran")
    setenv("I_MPI_F77",  "gfortran")
    setenv("I_MPI_F90",  "gfortran")

    setenv("MPI_DIR",    "]] .. PathCat(path, "mpi", ver) .. [[")

    prepend_path("MODULEPATH", "]] .. C.ONEAPIMODS .. [[")
    prepend_path("MODULEPATH", "]] .. C.DEPPATH .. "/" .. gnu .. [[-impi")

    load("mpi/" .. version)

    family("MPI")

    ]])
    end -- modtype="gnu-mpi"

    -- Template for lmod defaults
    if modtype == "modulerc" then
        if type(Defaults[ver]) == "table" then
            local bodytext = "-- Defaults for Intel(R) oneAPI Toolkit " .. Defaults.xref[ver] .. "\n\n"
            for k, v in pairs(Defaults[ver]) do
                bodytext = bodytext .. "module_version(\"" .. k .. "/" .. v .. "\", \"default\")\n"
            end
            return (header(nil) .. bodytext)
        else
            return ""
        end
    end

    error("Function ModuleText called with undefined filetype.", 2)
    os.exit(1)
end

-- Print command line help
local function printhelp(isfull)
    print("USAGE:\n  " .. arg[0] .. " COMMAND TYPE [arg] ")
    if isfull then
        print("\n  COMMANDs")
        for k, v in pairs(Commands) do
            if not v.ishidden then
                print(string.format("  %-10s", k) .. v.help)
            end
        end
        print("\n  TYPEs")
        for k, v in pairs(ModTypes) do
            print(string.format("  %-10s", k) .. v.help)
        end
    end
    print()
end

-- Find the default version
local function find_default(path, isfullpath)
    local linkinfo = lfs.symlinkattributes(PathCat(path, "default"))
    if not linkinfo then
        return nil
    end
    if not lfs.attributes(PathCat(path, linkinfo.target), "mode") then
        printformat("Default module points to missing target " ..
            linkinfo.target, "warning")
        return nil
    end
    if linkinfo.mode ~= "link" then
        printformat(path .. " is not a link", "warning")
        return nil
    end
    if isfullpath then
        return path .. linkinfo.target
    else
        return linkinfo.target
    end
end

-- Find all OpenHPC LMOD modules
local function find_mods(modtype, path)
    local path = ModTypes[modtype].path
    local modlist = {}
    printformat("Searching for " .. ModTypes[modtype].name .. " modules.", "info")
    local modlist = {}
    local foundfiles, iserror = RunOSCommand("grep -lr -m1 '^" .. C.SIGTEXT ..
        "' " .. C.OHPCROOT .. " 2>/dev/null")
    if iserror then
        printformat("No modules found", "step")
        return nil
    end
    local foundfiles = ListDir(path, false, nil, "file")
    if foundfiles == {} then
        printformat("No modules found", "step")
        return nil
    end
    for _, l in ipairs(StringtoArray(foundfiles)) do
        local modname = libgen.basename(l):gsub(".lua", "")
        local topline, iserror = ReadFirstLine(l)
        if not iserror and topline then
            if topline:find(C.SIGTEXT) then
                modlist[modname] = { file = l, isdiff = false }
            else
                modlist[modname] = { file = l, isdiff = true }
            end
        else
            printformat(l .. " could not be read", "warning")
        end
    end
    return modlist
end

-- Scan directory recursively to determine which tools are installed
local function find_tools(path, modtype)
    local mod = ModTypes[modtype]
    local toollist = {}
    for d in ListDir(PathCat(path, mod.name), false, "2*", "directory") do
        local searchpath = PathCat(path, mod.name, d)
        local _, isnotfull = RunOSCommand("find " .. searchpath ..
            " 2>/dev/null | grep " .. mod.find)
        local _, isnotrt = RunOSCommand("find " .. searchpath ..
            " 2>/dev/null | grep " .. mod.rt)
        if isnotfull and not isnotrt then
            toollist[d] = "runtimes"
        end
        if not isnotfull and not isnotrt then
            toollist[d] = "full version"
        end
        if not isnotfull and isnotrt then
            toollist[d] = "incomplete install (ignored)"
        end
    end
    return toollist
end

-- Generate a symbolic link to a file
local function new_link(path, link)
    local mode = lfs.symlinkattributes(link, "mode")
    if mode and mode ~= "link" then
        printformat("Cannot create link " .. link .. "\n   " .. mode ..
            " exists", "warning")
        return false
    end
    if mode == "link" then
        local isok, err = os.remove(link)
        if not isok then
            printformat("Cannot delete link " .. link .. "\n   " ..
                tostring(err), "warning")
            return false
        end
    end
    local isok, err = lfs.link(path, link, true)
    if not isok then
        printformat("Cannot create link " .. link .. "\n   " ..
            tostring(err), "warning")
        return false
    else
        return true
    end
end

-- oneAPI toolkit path handler; use default if not provided
-- Check the path for a valid installation
local function oneapipath(path)
    local rootpath = path
    if not path or path == "" then
        rootpath = C.ONEAPIPATH
        printformat("Using default path " .. rootpath, "info")
    else
        printformat("Using path " .. rootpath, "info")
    end
    if not (dir_exists(rootpath, false)) then
        printformat("Cannot find oneAPI installation in " .. rootpath, "error")
    end
    if lfs.symlinkattributes(PathCat(rootpath, C.MODSCRIPT), "mode") ~= "file" then
        printformat("Cannot find oneAPI module script in " .. rootpath, "error")
    end
    return rootpath
end

---------------------
-- Command Methods --
---------------------

-- Output full help text
local function scripthelp(_, _)
    print(description())
    printhelp(true)
end

-- Create new modulefiles, overwriting old ones
local function update_mods(modtype, path)
    local modlist = setmetatable({}, ModMT)
    printformat("Updating oneAPI modules " .. C.ONEAPIMODS, "header")
    local rootpath = oneapipath(path)
    printformat("Regenerating oneAPI modulefile links", "info")
    local tmpdir, err = stdlib.mkdtemp(os.tmpname() .. ".XXXXXX")
    if tmpdir == nil then
        printformat("Cannot create temporary directory\n" .. err, "error")
    end
    dir_exists(C.ONEAPIMODS, true)
    dir_exists(ModTypes[modtype].path, true)
    -- Run the oneAPI module script
    local _, iserr = RunOSCommand("cd " ..
        rootpath .. " && . " .. PathCat(".", C.MODSCRIPT) .. C.SCRIPTOPTS .. "\'" .. tmpdir .. "\'")
    if iserr then
        printformat("Cannot update oneAPI modules", "error")
    end
    -- Create base oneAPI module loader
    if modtype == "compiler" then
        dir_exists(C.MODPATH, true)
        printformat("Creating new oneAPI modulefile", "info")
        local f = PathCat(C.MODPATH, "oneapi.lua")
        printformat(f, "step")
        WriteFile(f, moduletext("oneapi", "core", rootpath))
    end
    -- Move the files to the correct location
    printformat("Creating new " .. modtype .. " modulefiles", "info")
    local filelist = ListDir(tmpdir, true, nil, "link")
    printformat("Setup Output List:\n" .. TDump(filelist), "debug")
    for _, f in ipairs(filelist) do
        if libgen.basename(f) ~= "latest" then
            local newfile = PathCat(C.ONEAPIMODS, First(f:gsub("^" .. tmpdir, "")))
            dir_exists(libgen.dirname(newfile), true)
            new_link(unistd.readlink(f), newfile)
            if newfile:find(PathCat(C.ONEAPIMODS, ModTypes[modtype].name) .. "/") ~= nil then
                local ver = libgen.basename(newfile)
                printformat("Found module " .. ver, "step")
                modlist:new(ver, PathCat(ModTypes[modtype].path, ver .. ".lua"), false)
                printformat(modlist[ver].file, "step")
                WriteFile(modlist[ver].file, moduletext(modtype, ver, rootpath))
            end
        end
    end
    if modlist == nil then
        printformat("No modules found", "step")
        return nil
    end
    local l = modlist:latest()
    if new_link(l .. ".lua", PathCat(ModTypes[modtype].path, "default")) then
        printformat("Default set to " .. l, "step")
    end
end


-- List all modules
local function list_mods(modtype, _)
    local modlist = find_mods(modtype)
    if modlist then
        for v, m in pairs(modlist) do
            local info = ""
            if m.isdiff then
                info = " (modified)"
            end
            if v == "oneapi" then
                info = " (core module)"
            end
            if v .. ".lua" == find_default(ModTypes[modtype].path, false) then
                info = info .. " (default)"
            end
            printformat(v .. " " .. info, "step")
        end
    end
end

-- Change the default module
local function new_default(modtype, version)
    if version ~= "oneapi" then
        if new_link(version .. ".lua", PathCat(ModTypes[modtype].path,
                "default")) then
            printformat("Default set to " .. version, "info")
        else
            printformat("Cannot set new default", "error")
        end
    else
        printformat("Version " .. version .. " doesn't exist", "error")
    end
end

-- Remove modulefiles
local function cleanup_mods(modtype, _)
    -- Delete the modules
    printformat("Deleting installed modules", "info")
    local default = PathCat(ModTypes[modtype].path, "default")
    if lfs.symlinkattributes(default, "mode") == "link" then
        printformat("Deleting default link for " .. modtype, "step")
        if not os.remove(default) then
            printformat("Cannot delete default link for " .. default, "substep")
        end
    end
    local modlist = find_mods(modtype)
    if modlist then
        for v, m in pairs(modlist) do
            if not m.isdiff then
                printformat("Deleting module " .. v, "step")
                if not os.remove(m.file) then
                    printformat("Cannot delete module", "substep")
                end
            else
                printformat("Ignoring modified module " .. v, "substep")
            end
        end
    end
    if modtype == "compiler" then
        -- Recursive deletion of oneAPI module directory
        printformat("Removing oneAPI modules directory " ..
            C.ONEAPIMODS, "info")
        if C.ONEAPIMODS:len() < 15 then
            printformat("Directory target path too short, aborting for safety",
                "info")
            os.exit(1)
        else
            local _, iserror = RunOSCommand("rm -rf " .. C.ONEAPIMODS)
            if iserror then
                printformat("Cannot remove oneAPI modules directory", "warning")
            end
        end
    end
end

-- Locate and print installations under path searchpath
local function locate_all(modtype, path)
    printformat("OneAPI Installation Summary", "header")
    local rootpath = oneapipath(path)
    printformat("Searching for " .. ModTypes[modtype].name ..
        " installations.", "info")
    local toollist = find_tools(rootpath, modtype)
    if toollist == {} then
        printformat("No modules found", "step")
    else
        for k, v in pairs(toollist) do
            printformat("Found " .. v .. " " .. k, "step")
        end
    end
end

local function print_mod(modtype, ver)
    print(moduletext(modtype, ver, C.ONEAPIPATH))
    if modtype == "compiler" then
        print("\n========================================\n")
        print(moduletext("modulerc", ver, C.ONEAPIPATH))
    end
end

------------------
-- Main Program --
------------------

ModTypes:new("compiler", "Intel(R) C and Fortran Compilers", C.MODPATH .. "/intel",
    "compiler", "/bin/icx", "/modulefiles/compiler")
ModTypes:new("gnu-mkl", "Intel(R) Math Kernel Library, for gcc", C.DEPPATH .. "/gnu/mkl",
    "mkl", "/include/mkl.h", "/modulefiles/mkl")
ModTypes:new("mpi", "Intel(R) MPI Compiler & Libraries", C.DEPPATH .. "/intel/impi",
    "mpi", "/bin/mpiicc", "/modulefiles/mpi")
ModTypes:new("gnu-mpi", "Intel(R) MPI Compiler & Libraries, for gcc", C.DEPPATH .. "/gnu/impi",
    "mpi", "/bin/mpigcc", "/modulefiles/mpi")
ModTypes:new("gnu" .. C.GNU .. "-mpi", "Intel(R) MPI Compiler & Libraries, for gcc" .. C.GNU,
    C.DEPPATH .. "/gnu" .. C.GNU .. "/impi", "mpi", "/bin/mpigcc", "/modulefiles/mpi")

Commands:new("help", "Command Help", 0, scripthelp, false)
Commands:new("--help", "Command Help", 0, scripthelp, true)
Commands:new("update", "Create new modulefiles; optional [arg] = path",
    1, update_mods, false)
Commands:new("find", "Show installations; optional [arg] = path",
    1, locate_all, false)
Commands:new("clean", "Remove all modulefiles", 1, cleanup_mods, false)
Commands:new("list", "List current modules", 1, list_mods, false)
Commands:new("default", "Set module to default; [arg] = version",
    2, new_default, true)
Commands:new("modtext", "Print a sample modulefile; [arg] = version",
    2, print_mod, true)

-- Check for command
if not arg[1] then
    printhelp(false)
    os.exit(1)
end
-- Check for valid command
local c = arg[1]:lower()
if not Commands[c] then
    printformat("Unrecognized command: " .. arg[1], "info")
    printhelp(true)
    os.exit(1)
end
local m
if Commands[c].argc >= 1 then
    -- Check for module type
    if not arg[2] then
        printformat("Missing module type", "info")
        printhelp(true)
        os.exit(1)
    else
        -- Check for valid module type
        m = arg[2]:lower()
        if not ModTypes[m] then
            printformat("Unrecognized module type: " .. arg[2], "info")
            printhelp(true)
            os.exit(1)
        end
    end
end
-- Check for required argument
if Commands[c].argc >= 2 and not arg[3] then
    printformat("Missing argument", "info")
    printhelp(true)
    os.exit(1)
end

Commands[c].call(m, arg[3])
os.exit(0)
